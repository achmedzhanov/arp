using System;
using System.IO;
using Antlr.StringTemplate;
using Arp.Common.Assertions;
using Arp.Generator.Names;
using Arp.Generator.Preprocessing;
using Arp.Generator.Preprocessing.Impl;

namespace Arp.Generator.Generating
{
    public class TreeElements
    {
        #region Templates

        public const string BASE =
            @"
group common;
ifcName(name) ::= <<I<name>
>>
implName(name) ::= <<
<name>Impl
>>";

        // TODO create reusable template for footer/headers

        public const string INTERFACE_DECLARATION =
            @"
/*
This file was generated by Arp.Generator
*/
#region Imports
using JetBrains.ReSharper.Psi.Xml.Tree;
$usings:{u |using $u$;
}$
#endregion

namespace $namespace$
{
    public partial interface $ifcName(name=name )$ : IElement 
    {
$if(noemptybody)$
        #region Attributes

$attributes:{a |            $a.type$ $a.name$ {get;}
}$
$end$
        #endregion

        #region Elements

$elements:{e |      $ifcName(name=e.type)$ $e.name$ {get;}
}$

$elementCollections:{e |        ICollection<$ifcName(name=e.type)$> $e.name$ {get;}
}$

        #endregion

$additional$ 

$endif$
    }
}
";
        public const string IMPL_DECLARATION =
            @"
/*
This file was generated by Arp.Generator
*/
#region Imports
using JetBrains.ReSharper.Psi.Xml.Tree;
$usings:{u |using $u$;
}$
#endregion

namespace $namespace$
{
    public partial partial class $implName(name=name )$ : XmlTag,  $ifcName(name=name )$
    {
$if(noemptybody)$
        #region Attributes

$attributes:{a |            $a.type$ $a.name$ {get {throw new NotImplementedException;} }
}$
$end$
        #endregion

        #region Elements

$elements:{e |      $ifcName(name=e.type)$ $e.name$ {get {throw new NotImplementedException;} }
}$

$elementCollections:{e |        ICollection<$ifcName(name=e.type)$> $e.name$ { {throw new NotImplementedException;} }
}$

        #endregion

$additional$ 

    IElement [] GetChildByRole(int role)
    {
        {throw new NotImplementedException;}
    }

    }

$endif$

}
";

 
        public const string PROPERTY_DECLARATION =
            @"
        $type$ $name$
        {
            get;
        }
}";

        #endregion

        private IFilesWriter fileWriter;
        private INameConverter nameConverter;
        private IPluralProvider pluralProvider;
        private string baseNamespace = "Arp.NH.Psi.Tree";
        
        private StringTemplateGroup group;
        private StringTemplateGroup templateGroup;


        public TreeElements()
        {
            group = new StringTemplateGroup(new StringReader(BASE));
            templateGroup = new StringTemplateGroup("interface");
            this.templateGroup.SuperGroup = group;
            this.templateGroup.DefineTemplate("interface", INTERFACE_DECLARATION);
            this.templateGroup.DefineTemplate("impl", IMPL_DECLARATION);

        }

        public IFilesWriter FileWriter
        {
            get { return fileWriter; }
            set { fileWriter = value; }
        }


        public INameConverter NameConverter
        {
            get { return nameConverter; }
            set { nameConverter = value; }
        }


        public IPluralProvider PluralProvider
        {
            get { return pluralProvider; }
            set { pluralProvider = value; }
        }


        public string BaseNamespace
        {
            get { return baseNamespace; }
            set { baseNamespace = value; }
        }

        public void GenerateElementInterface(ITypeInfo typeGenerationInfo)
        {
            Assert.CheckNotNull(fileWriter);
            Assert.CheckNotNull(nameConverter);
            Assert.CheckNotNull(pluralProvider);

            StringTemplate stringTemplate = templateGroup.GetInstanceOf("interface");

            //StringTemplate stringTemplate = new StringTemplate(INTERFACE_DECLARATION);

            string baseName = nameConverter.ConvertTypeName(typeGenerationInfo.BaseName);

            PrepareTreeElementTemplate(typeGenerationInfo, stringTemplate, baseName);
            string ret = stringTemplate.ToString();
            string ifcName = GetIfcName(baseName);
            fileWriter.Write(ifcName + ".generated.cs", ret);

            string onceGenerateFile = ifcName + ".cs";
            if (!fileWriter.Exists(onceGenerateFile))
            {
                stringTemplate.RemoveAttribute("noemptybody");
                fileWriter.Write(onceGenerateFile, stringTemplate.ToString());
            }
        }

        private void PrepareTreeElementTemplate(ITypeInfo typeGenerationInfo, StringTemplate stringTemplate, string baseName)
        {
            stringTemplate.SetAttribute("namespace", BaseNamespace);
            stringTemplate.SetAttribute("name", baseName);

            stringTemplate.SetAttribute("noemptybody", true);

            foreach (IAttributeInfo info in typeGenerationInfo.AttributesInfo)
            {
                stringTemplate.SetAttribute("attributes.{type,name}", "IXmlAttribute", nameConverter.ConvertAttributeName(info.Name ));
            }

            foreach (INestedElementInfo nestedElementInfo in typeGenerationInfo.NestedElementsInfo)
            {
                if (!nestedElementInfo.IsCollection)
                {
                    stringTemplate.SetAttribute("elements.{type,name}", nameConverter.ConvertTypeName(nestedElementInfo.Element.TypeInfo.BaseName), 
                                                nameConverter.ConvertAttributeName(nestedElementInfo.Element.Name));
                }
                else
                {
                    foreach (IElementInfo collectionElementInfo in nestedElementInfo.Elements)
                    {
                        string name = nameConverter.ConvertAttributeName(collectionElementInfo.Name);
                        name = pluralProvider.Plural(name);
                        stringTemplate.SetAttribute("elementCollections.{type,name}", nameConverter.ConvertTypeName(collectionElementInfo.TypeInfo.BaseName),
                                                    name);
                    }
                }
            }

            stringTemplate.SetAttribute("attitional", ";;");
        }

        public void GenerateElementImpl(ITypeInfo typeGenerationInfo)
        {
            Assert.CheckNotNull(fileWriter);
            Assert.CheckNotNull(nameConverter);
            Assert.CheckNotNull(pluralProvider);

            StringTemplate stringTemplate = templateGroup.GetInstanceOf("impl");

            string baseName = nameConverter.ConvertTypeName(typeGenerationInfo.BaseName);

            PrepareTreeElementTemplate(typeGenerationInfo, stringTemplate, baseName);

            string ret = stringTemplate.ToString();
            string implName = GetImplName(baseName);
            fileWriter.Write("Impl\\" + implName + ".generated.cs", ret);

            string onceGenerateFile = "Impl\\" + implName + ".cs";
            if (!fileWriter.Exists(onceGenerateFile))
            {
                stringTemplate.RemoveAttribute("noemptybody");
                fileWriter.Write(onceGenerateFile, stringTemplate.ToString());
            }

        }


        private string GetIfcName(string baseName)
        {
            StringTemplate ifcNameInstance = templateGroup.GetInstanceOf("ifcName");
            ifcNameInstance.SetAttribute("name", baseName);
            return ifcNameInstance.ToString();
        }

        private string GetImplName(string baseName)
        {
            StringTemplate ifcNameInstance = templateGroup.GetInstanceOf("implName");
            ifcNameInstance.SetAttribute("name", baseName);
            return ifcNameInstance.ToString();
        }
    }
}